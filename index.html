<!doctype html>
<html>

<head>
    <title>Escena montacargas</title>
    <style>
        body {
            background-color: grey;
        }

        canvas {
            background-color: white;
        }

        textarea {
            background-color: black;
        }
    </style>
    <script src="js/dat.gui/dat.gui.min.js"></script>
    <script src="js/glmatrix/gl-matrix.js"></script>
</head>

<body>

    <center>
        <canvas id="my-canvas" width="1000" height="800">
            Your browser does not support the HTML5 canvas element.
        </canvas>
    </center>

    <script type="text/javascript" src="js/glmatrix/gl-matrix.js"></script>

    <script id="shader-vs" type="x-shader/x-vertex">

            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;
            attribute vec2 aTextureCoord;

            uniform mat4 modelMatrix;            
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;

            uniform mat4 normalMatrix;

            varying vec3 vNormal;    
            varying vec3 vPosWorld;  
            varying highp vec2 vTextureCoord;

            void main(void) {
                gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);

                vPosWorld=(modelMatrix*vec4(aVertexPosition,1.0)).xyz;    //la posicion en coordenadas de mundo
                vNormal=(normalMatrix*vec4(aVertexNormal,1.0)).xyz;       //la normal en coordenadas de mundo                
                vTextureCoord = aTextureCoord;
            }
        </script>

    <script id="shader-fs" type="x-shader/x-fragment">
            precision highp float;
            varying vec3 vNormal;
            varying vec3 vPosWorld;
            varying highp vec2 vTextureCoord;
            uniform sampler2D uSampler;

            void main(void) {

                vec3 lightVec=normalize(vec3(0.0,3.0,5.0)-vPosWorld);
                vec3 diffColor=mix(vec3(0.7,0.7,0.7),vNormal,0.4);
                vec3 color=dot(lightVec,vNormal)*diffColor+vec3(0.2,0.2,0.2);

                gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));

            }
        </script>

    <script type="module">
        import { Escena } from './js/objects/Escena.js'
        import { mouseWheelListener, mouseMoveListener, mouseUpListener, mouseDownListener, keyUpListener, keyDownListener } from './js/handle_comandos.js'
        import { initMenu } from './js/gui.js'
        import { Camara } from './js/camara.js'

        var mat4 = glMatrix.mat4;
        var vec3 = glMatrix.vec3;

        var canvas = null,
            fragmentShader = null,
            vertexShader = null;

        var escena = null;
        var camara = null;

        var modelMatrix = mat4.create();
        var viewMatrix = mat4.create();
        var projMatrix = mat4.create();
        var normalMatrix = mat4.create();
        var camaraMatrix = mat4.create();


        function initWebGL() {

            canvas = document.getElementById("my-canvas");

            try {
                window.gl = canvas.getContext("webgl");

            } catch (e) {
                alert("Error: Your browser does not appear to support WebGL.");
            }

            if (window.gl) {

                setupWebGL();
                initShaders();
                escena = new Escena();
                camara = new Camara(escena.getCarro(), escena.getPosImpresora(), escena.getPosEstanteria());
                setupVertexShaderMatrix();
                initMenu(escena);
                setupListeners();

                drawScene();
                tick();

            } else {
                alert("Error: Your browser does not appear to support WebGL.");
            }

        }

        function setupListeners() {
            document.addEventListener('keydown', function (event) { keyDownListener(event, escena, camara) });
            document.addEventListener('keyup', function (event) { keyUpListener(event, escena) });
            document.addEventListener('mousedown', mouseDownListener);
            document.addEventListener('mousemove', function (event) { mouseMoveListener(event, camara, canvas.width, canvas.height) });
            document.addEventListener('mouseup', mouseUpListener);
            document.addEventListener('wheel', function (event) { mouseWheelListener(event, camara) });
        }

        function setupWebGL() {
            window.gl.enable(window.gl.DEPTH_TEST);
            //set the clear color
            window.gl.clearColor(0.1, 0.1, 0.2, 1.0);
            window.gl.clear(window.gl.COLOR_BUFFER_BIT | window.gl.DEPTH_BUFFER_BIT);

            window.gl.viewport(0, 0, canvas.width, canvas.height);

            // Matrix de Proyeccion Perspectiva
            mat4.perspective(projMatrix, 45, canvas.width / canvas.height, 0.1, 100.0);

            // Matriz de vista
            mat4.identity(viewMatrix);
            mat4.translate(viewMatrix, viewMatrix, [0.0, 0.0, -5.0]);
        }


        function initShaders() {
            //get shader source
            var fs_source = document.getElementById('shader-fs').innerHTML,
                vs_source = document.getElementById('shader-vs').innerHTML;

            //compile shaders    
            vertexShader = makeShader(vs_source, window.gl.VERTEX_SHADER);
            fragmentShader = makeShader(fs_source, window.gl.FRAGMENT_SHADER);

            //create program
            window.glProgram = window.gl.createProgram();

            //attach and link shaders to the program
            window.gl.attachShader(window.glProgram, vertexShader);
            window.gl.attachShader(window.glProgram, fragmentShader);
            window.gl.linkProgram(window.glProgram);

            if (!window.gl.getProgramParameter(window.glProgram, window.gl.LINK_STATUS)) {
                alert("Unable to initialize the shader program.");
            }

            //use program
            window.gl.useProgram(window.glProgram);
        }

        function makeShader(src, type) {
            //compile the vertex shader
            var shader = window.gl.createShader(type);
            window.gl.shaderSource(shader, src);
            window.gl.compileShader(shader);

            if (!window.gl.getShaderParameter(shader, window.gl.COMPILE_STATUS)) {
                console.log("Error compiling shader: " + window.gl.getShaderInfoLog(shader));
            }
            return shader;
        }

        function setupVertexShaderMatrix() {
            var modelMatrixUniform = window.gl.getUniformLocation(window.glProgram, "modelMatrix");
            var viewMatrixUniform = window.gl.getUniformLocation(window.glProgram, "viewMatrix");
            var projMatrixUniform = window.gl.getUniformLocation(window.glProgram, "projMatrix");
            var normalMatrixUniform = window.gl.getUniformLocation(window.glProgram, "normalMatrix");

            window.gl.uniformMatrix4fv(modelMatrixUniform, false, modelMatrix); // REVISAR: no hay que hacer nada con la matriz modelMatrix? es solo la identidad
            window.gl.uniformMatrix4fv(viewMatrixUniform, false, viewMatrix);
            window.gl.uniformMatrix4fv(projMatrixUniform, false, projMatrix);
            window.gl.uniformMatrix4fv(normalMatrixUniform, false, normalMatrix);
        }

        function drawScene() {
            setupVertexShaderMatrix();
            camaraMatrix = camara.getCameraMatrix();
            // revisar la matriz de camara nunca se setea como viewMatrix????

            escena.dibujar(camaraMatrix); // revisar!!
        }

        function tick() {
            requestAnimationFrame(tick);

            window.gl.clear(window.gl.COLOR_BUFFER_BIT | window.gl.DEPTH_BUFFER_BIT);
            window.gl.clearColor(0, 0, 0, 1);

            drawScene();
        }

        window.onload = initWebGL;

    </script>


</body>

</html>