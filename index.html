<!doctype html>
<html>

<head>
    <title>Escena montacargas</title>
    <link rel="icon" type="image/png" href="favicon.ico" />
    <style>
        body {
            background-color: grey;
        }

        canvas {
            background-color: white;
        }

        textarea {
            background-color: black;
        }
    </style>
    <script src="js/dat.gui/dat.gui.min.js"></script>
    <script src="js/glmatrix/gl-matrix.js"></script>
</head>

<body>

    <div style="overflow: hidden;">
        <center>
            <canvas id="my-canvas" width="1000" height="800">
                Your browser does not support the HTML5 canvas element.
            </canvas>
        </center>
    </div>

    <script type="text/javascript" src="js/glmatrix/gl-matrix.js"></script>

    <script id="shader-vs" type="x-shader/x-vertex">

            precision highp float;

            attribute vec3 aVertexPosition;
            attribute vec3 aVertexNormal;
            attribute vec2 aTextureCoord;

            uniform mat4 modelMatrix;            
            uniform mat4 viewMatrix;
            uniform mat4 projMatrix;
            uniform mat4 normalMatrix;

            // uniform vec3 uColor
            // uniform highp float uShininess;

            varying vec3 vNormal;    
            varying vec3 vPosWorld;  
            varying highp vec2 vTextureCoord;

            void main(void) {
                gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(aVertexPosition, 1.0);

                vPosWorld=(modelMatrix*vec4(aVertexPosition,1.0)).xyz;    //la posicion en coordenadas de mundo
                vNormal=(normalMatrix*vec4(aVertexNormal,1.0)).xyz;       //la normal en coordenadas de mundo                
                vTextureCoord = aTextureCoord;
            }
        </script>

    <script id="shader-fs" type="x-shader/x-fragment">
            precision highp float;
            varying vec3 vNormal;
            varying vec3 vPosWorld;
            varying highp vec2 vTextureCoord;
            uniform sampler2D uSampler;

            uniform vec3 uCameraPos;
            uniform vec3 uColor;
            uniform highp float uShininess;
            uniform bool hasTexture;

            struct SpotLightInfo {
                vec4 position;
                float intensityA;
                float intensityD;
                float intensityS;
                vec3 direction;
                float exponent; // exponente de atenuaci√≥n
                float cutoff; 
            };

            uniform SpotLightInfo Spot1;
            uniform SpotLightInfo Spot2;
            uniform SpotLightInfo Spot3;
            uniform SpotLightInfo Spot4;
            uniform SpotLightInfo Spot5;
            uniform SpotLightInfo Spot6;

            uniform vec4 uPosPoint1;
            uniform vec4 uPosPoint2;
            uniform vec4 uPosPoint3;
            uniform vec4 uPosPoint4;

            vec3 calculateSpotlight( SpotLightInfo thisSpot ){
                vec3 spotDir = normalize(thisSpot.direction);

                vec3 s = normalize( vec3(thisSpot.position) - vPosWorld ); // vector from light to vertex
                
                vec4 textureVec;
                if (hasTexture) {
                    textureVec = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
                } else {
                    textureVec = vec4(uColor, 1.0);
                }
                vec3 Ka = vec3(textureVec.s, textureVec.t, textureVec.p);
                vec3 Kd = vec3(textureVec.s, textureVec.t, textureVec.p);
                vec3 Ks = vec3(1,1,1);

                float angle = acos( dot(-s, spotDir) );
                float cutoff = radians( clamp( thisSpot.cutoff, 0.0, 90.0 ) );
                vec3 ambient = thisSpot.intensityA * Ka;

                if (angle < cutoff) {
                    float spotFactor = pow( dot(-s, spotDir), thisSpot.exponent );
                    vec3 v = normalize(vec3(vec3(uCameraPos) - vec3(vPosWorld)));
                    vec3 h = normalize( v + s );
                    vec3 SpecularLight = spotFactor * thisSpot.intensityS * Ks * pow(dot(h, vNormal), uShininess);
                    vec3 DiffuseLight = spotFactor * thisSpot.intensityD * Kd * max(dot(s, vNormal), 0.0 );
                    if (uShininess == 0.0){
                        SpecularLight = vec3(0.0, 0.0, 0.0);
                    }
                    return max(ambient, DiffuseLight + SpecularLight);
                } else {
                    return ambient;
                }
            }

            vec3 calculatePointLight(vec4 lightPos) {

                vec4 textureVec = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
                vec3 Ka = vec3(textureVec.s, textureVec.t, textureVec.p);
                vec3 Kd = vec3(1,0,0);
                vec3 Ks = vec3(1,0,0);
                
                vec3 n = normalize(vNormal);
                vec3 s = normalize(vPosWorld - vec3(lightPos));
                vec3 v = normalize(uCameraPos - vPosWorld );
                vec3 r = reflect (-s, n );

                highp float factorAtenuacion = 1.0/(1.0 + 10.0 * length(vec3(vPosWorld) - vec3(lightPos))); // decaimiento lineal

                highp float intensityA = 0.0;
                highp float intensityD = 0.7;
                highp float intensityS = 0.5;

                vec3 AmbientLight = Ka * intensityA;
                vec3 DiffuseLight = Kd * max(dot (s , n), 0.0 ) * intensityD * factorAtenuacion;
                vec3 SpecularLight = Ks * pow( dot( r,v ), uShininess) * intensityS * factorAtenuacion;
                if (uShininess == 0.0){
                    SpecularLight = vec3(0.0,0.0,0.0);
                }
                return max(AmbientLight, DiffuseLight + SpecularLight);

            }

            void main(void) {

                vec3 totalSpotLight = calculateSpotlight(Spot1) + calculateSpotlight(Spot2) + calculateSpotlight(Spot3) + calculateSpotlight(Spot4) + calculateSpotlight(Spot5) + calculateSpotlight(Spot6);
                vec3 totalPointLight = calculatePointLight(uPosPoint1) + calculatePointLight(uPosPoint2) + calculatePointLight(uPosPoint3) + calculatePointLight(uPosPoint4);
                
                gl_FragColor = vec4( totalSpotLight + totalPointLight, 1.0);

            }
        </script>

    <script type="module">
        import { Escena } from './js/objects/Escena.js'
        import { mouseWheelListener, mouseMoveListener, mouseUpListener, mouseDownListener, keyUpListener, keyDownListener } from './js/handle_comandos.js'
        import { initMenu } from './js/gui.js'
        import { Camara } from './js/camara.js'

        var mat4 = glMatrix.mat4;
        var vec3 = glMatrix.vec3;
        var vec4 = glMatrix.vec4;

        var canvas = null,
            fragmentShader = null,
            vertexShader = null;

        var escena = null;
        var camara = null;

        var modelMatrix = mat4.create();
        var viewMatrix = mat4.create();
        var projMatrix = mat4.create();
        var normalMatrix = mat4.create();
        var camaraMatrix = mat4.create();


        function initWebGL() {

            canvas = document.getElementById("my-canvas");
            canvas.height = window.innerHeight - 50;
            canvas.width = Math.min(window.innerWidth, canvas.width);

            try {
                window.gl = canvas.getContext("webgl");

            } catch (e) {
                alert("Error: Your browser does not appear to support WebGL.");
            }

            if (window.gl) {

                setupWebGL();
                initShaders();
                escena = new Escena();
                camara = new Camara(escena.getCarro(), escena.getPosImpresora(), escena.getPosEstanteria());
                setupVertexShaderMatrix();
                initMenu(escena);
                setupListeners();

                drawScene();
                tick();

            } else {
                alert("Error: Your browser does not appear to support WebGL.");
            }

        }

        function setupListeners() {
            document.addEventListener('keydown', function (event) { keyDownListener(event, escena, camara) });
            document.addEventListener('keyup', function (event) { keyUpListener(event, escena) });
            document.addEventListener('mousedown', mouseDownListener);
            document.addEventListener('mousemove', function (event) { mouseMoveListener(event, camara, canvas.width, canvas.height) });
            document.addEventListener('mouseup', mouseUpListener);
            document.addEventListener('wheel', function (event) { mouseWheelListener(event, camara) });
        }

        function setupWebGL() {
            window.gl.enable(window.gl.DEPTH_TEST);
            //set the clear color
            window.gl.clearColor(0.1, 0.1, 0.2, 1.0);
            window.gl.clear(window.gl.COLOR_BUFFER_BIT | window.gl.DEPTH_BUFFER_BIT);

            window.gl.viewport(0, 0, canvas.width, canvas.height);

            // Matrix de Proyeccion Perspectiva
            mat4.perspective(projMatrix, 45, canvas.width / canvas.height, 0.1, 100.0);

            // Matriz de vista
            mat4.identity(viewMatrix);
            mat4.translate(viewMatrix, viewMatrix, [0.0, 0.0, -5.0]);
        }


        function initShaders() {
            //get shader source
            var fs_source = document.getElementById('shader-fs').innerHTML,
                vs_source = document.getElementById('shader-vs').innerHTML;

            //compile shaders    
            vertexShader = makeShader(vs_source, window.gl.VERTEX_SHADER);
            fragmentShader = makeShader(fs_source, window.gl.FRAGMENT_SHADER);

            //create program
            window.glProgram = window.gl.createProgram();

            //attach and link shaders to the program
            window.gl.attachShader(window.glProgram, vertexShader);
            window.gl.attachShader(window.glProgram, fragmentShader);
            window.gl.linkProgram(window.glProgram);

            if (!window.gl.getProgramParameter(window.glProgram, window.gl.LINK_STATUS)) {
                alert("Unable to initialize the shader program.");
            }

            //use program
            window.gl.useProgram(window.glProgram);
        }

        function makeShader(src, type) {
            //compile the vertex shader
            var shader = window.gl.createShader(type);
            window.gl.shaderSource(shader, src);
            window.gl.compileShader(shader);

            if (!window.gl.getShaderParameter(shader, window.gl.COMPILE_STATUS)) {
                console.log("Error compiling shader: " + window.gl.getShaderInfoLog(shader));
            }
            return shader;
        }

        function setupVertexShaderMatrix() {
            var modelMatrixUniform = window.gl.getUniformLocation(window.glProgram, "modelMatrix");
            var viewMatrixUniform = window.gl.getUniformLocation(window.glProgram, "viewMatrix");
            var projMatrixUniform = window.gl.getUniformLocation(window.glProgram, "projMatrix");
            var normalMatrixUniform = window.gl.getUniformLocation(window.glProgram, "normalMatrix");

            window.gl.uniformMatrix4fv(modelMatrixUniform, false, modelMatrix); // REVISAR: no hay que hacer nada con la matriz modelMatrix? es solo la identidad
            window.gl.uniformMatrix4fv(viewMatrixUniform, false, viewMatrix);
            window.gl.uniformMatrix4fv(projMatrixUniform, false, projMatrix);
            window.gl.uniformMatrix4fv(normalMatrixUniform, false, normalMatrix);
        }

        function drawScene() {
            setupVertexShaderMatrix();
            camaraMatrix = camara.getCameraMatrix();
            gl.uniformMatrix4fv(gl.getUniformLocation(glProgram, "viewMatrix"), false, camaraMatrix);

            escena.dibujar(mat4.create());
        }

        function tick() {
            requestAnimationFrame(tick);

            window.gl.clear(window.gl.COLOR_BUFFER_BIT | window.gl.DEPTH_BUFFER_BIT);
            window.gl.clearColor(0, 0, 0, 1);

            drawScene();
        }

        window.onload = initWebGL;

    </script>


</body>

</html>